// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: segment.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Segment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SegmentMultiError, or nil if none found.
func (m *Segment) ValidateAll() error {
	return m.validate(true)
}

func (m *Segment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentMultiError(errors)
	}

	return nil
}

// SegmentMultiError is an error wrapping multiple validation errors returned
// by Segment.ValidateAll() if the designated constraints aren't met.
type SegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentMultiError) AllErrors() []error { return m }

// SegmentValidationError is the validation error returned by Segment.Validate
// if the designated constraints aren't met.
type SegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentValidationError) ErrorName() string { return "SegmentValidationError" }

// Error satisfies the builtin error interface
func (e SegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentValidationError{}

// Validate checks the field values on SegmentField with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SegmentField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentField with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SegmentFieldMultiError, or
// nil if none found.
func (m *SegmentField) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	switch v := m.Value.(type) {
	case *SegmentField_StringValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStringValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "StringValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "StringValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStringValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "StringValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedStringValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedStringValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedStringValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedStringValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedStringValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedStringValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_IntValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIntValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "IntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "IntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "IntValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedIntValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedIntValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedIntValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedIntValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_UintValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUintValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "UintValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "UintValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUintValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "UintValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedUintValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedUintValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedUintValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedUintValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedUintValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedUintValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_FloatValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFloatValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "FloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "FloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFloatValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "FloatValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedFloatValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedFloatValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedFloatValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedFloatValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_BoolValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBoolValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "BoolValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "BoolValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBoolValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "BoolValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedBoolValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedBoolValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedBoolValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedBoolValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedBoolValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedBoolValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_BlobValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlobValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "BlobValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "BlobValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlobValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "BlobValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedBlobValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedBlobValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedBlobValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedBlobValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedBlobValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedBlobValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RangeIntValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRangeIntValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RangeIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RangeIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRangeIntValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RangeIntValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedRangeIntValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedRangeIntValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedRangeIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedRangeIntValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedRangeIntValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedRangeIntValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RangeFloatValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRangeFloatValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RangeFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RangeFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRangeFloatValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RangeFloatValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedRangeFloatValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedRangeFloatValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedRangeFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedRangeFloatValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedRangeFloatValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedRangeFloatValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_GeoPointValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGeoPointValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "GeoPointValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "GeoPointValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeoPointValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "GeoPointValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedGeoPointValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedGeoPointValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedGeoPointValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedGeoPointValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedGeoPointValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedGeoPointValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_GeoRectValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGeoRectValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "GeoRectValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "GeoRectValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeoRectValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "GeoRectValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentField_RepeatedGeoRectValue:
		if v == nil {
			err := SegmentFieldValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepeatedGeoRectValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedGeoRectValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldValidationError{
						field:  "RepeatedGeoRectValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepeatedGeoRectValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldValidationError{
					field:  "RepeatedGeoRectValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SegmentFieldMultiError(errors)
	}

	return nil
}

// SegmentFieldMultiError is an error wrapping multiple validation errors
// returned by SegmentField.ValidateAll() if the designated constraints aren't met.
type SegmentFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldMultiError) AllErrors() []error { return m }

// SegmentFieldValidationError is the validation error returned by
// SegmentField.Validate if the designated constraints aren't met.
type SegmentFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldValidationError) ErrorName() string { return "SegmentFieldValidationError" }

// Error satisfies the builtin error interface
func (e SegmentFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldValidationError{}

// Validate checks the field values on SegmentFieldString with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldString with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldStringMultiError, or nil if none found.
func (m *SegmentFieldString) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldStringMultiError(errors)
	}

	return nil
}

// SegmentFieldStringMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldString.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldStringMultiError) AllErrors() []error { return m }

// SegmentFieldStringValidationError is the validation error returned by
// SegmentFieldString.Validate if the designated constraints aren't met.
type SegmentFieldStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldStringValidationError) ErrorName() string {
	return "SegmentFieldStringValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldStringValidationError{}

// Validate checks the field values on SegmentFieldRepeatedString with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedString with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedStringMultiError, or nil if none found.
func (m *SegmentFieldRepeatedString) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedStringMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedStringMultiError is an error wrapping multiple
// validation errors returned by SegmentFieldRepeatedString.ValidateAll() if
// the designated constraints aren't met.
type SegmentFieldRepeatedStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedStringMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedStringValidationError is the validation error returned
// by SegmentFieldRepeatedString.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedStringValidationError) ErrorName() string {
	return "SegmentFieldRepeatedStringValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedStringValidationError{}

// Validate checks the field values on SegmentFieldInt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldIntMultiError, or nil if none found.
func (m *SegmentFieldInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldIntMultiError(errors)
	}

	return nil
}

// SegmentFieldIntMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldInt.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldIntMultiError) AllErrors() []error { return m }

// SegmentFieldIntValidationError is the validation error returned by
// SegmentFieldInt.Validate if the designated constraints aren't met.
type SegmentFieldIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldIntValidationError) ErrorName() string { return "SegmentFieldIntValidationError" }

// Error satisfies the builtin error interface
func (e SegmentFieldIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldIntValidationError{}

// Validate checks the field values on SegmentFieldRepeatedInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedInt with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedIntMultiError, or nil if none found.
func (m *SegmentFieldRepeatedInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedIntMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedIntMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRepeatedInt.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRepeatedIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedIntMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedIntValidationError is the validation error returned by
// SegmentFieldRepeatedInt.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedIntValidationError) ErrorName() string {
	return "SegmentFieldRepeatedIntValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedIntValidationError{}

// Validate checks the field values on SegmentFieldUInt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldUInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldUInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldUIntMultiError, or nil if none found.
func (m *SegmentFieldUInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldUInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldUIntMultiError(errors)
	}

	return nil
}

// SegmentFieldUIntMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldUInt.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldUIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldUIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldUIntMultiError) AllErrors() []error { return m }

// SegmentFieldUIntValidationError is the validation error returned by
// SegmentFieldUInt.Validate if the designated constraints aren't met.
type SegmentFieldUIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldUIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldUIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldUIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldUIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldUIntValidationError) ErrorName() string { return "SegmentFieldUIntValidationError" }

// Error satisfies the builtin error interface
func (e SegmentFieldUIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldUInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldUIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldUIntValidationError{}

// Validate checks the field values on SegmentFieldRepeatedUInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedUInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedUInt with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedUIntMultiError, or nil if none found.
func (m *SegmentFieldRepeatedUInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedUInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedUIntMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedUIntMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRepeatedUInt.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRepeatedUIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedUIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedUIntMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedUIntValidationError is the validation error returned by
// SegmentFieldRepeatedUInt.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedUIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedUIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedUIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedUIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedUIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedUIntValidationError) ErrorName() string {
	return "SegmentFieldRepeatedUIntValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedUIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedUInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedUIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedUIntValidationError{}

// Validate checks the field values on SegmentFieldFloat with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldFloat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldFloat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldFloatMultiError, or nil if none found.
func (m *SegmentFieldFloat) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldFloat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldFloatMultiError(errors)
	}

	return nil
}

// SegmentFieldFloatMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldFloat.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldFloatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldFloatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldFloatMultiError) AllErrors() []error { return m }

// SegmentFieldFloatValidationError is the validation error returned by
// SegmentFieldFloat.Validate if the designated constraints aren't met.
type SegmentFieldFloatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldFloatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldFloatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldFloatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldFloatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldFloatValidationError) ErrorName() string {
	return "SegmentFieldFloatValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldFloatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldFloat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldFloatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldFloatValidationError{}

// Validate checks the field values on SegmentFieldRepeatedFloat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedFloat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedFloat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedFloatMultiError, or nil if none found.
func (m *SegmentFieldRepeatedFloat) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedFloat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedFloatMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedFloatMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRepeatedFloat.ValidateAll() if the
// designated constraints aren't met.
type SegmentFieldRepeatedFloatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedFloatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedFloatMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedFloatValidationError is the validation error returned by
// SegmentFieldRepeatedFloat.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedFloatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedFloatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedFloatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedFloatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedFloatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedFloatValidationError) ErrorName() string {
	return "SegmentFieldRepeatedFloatValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedFloatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedFloat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedFloatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedFloatValidationError{}

// Validate checks the field values on SegmentFieldBool with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldBool) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldBool with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldBoolMultiError, or nil if none found.
func (m *SegmentFieldBool) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldBool) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldBoolMultiError(errors)
	}

	return nil
}

// SegmentFieldBoolMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldBool.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldBoolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldBoolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldBoolMultiError) AllErrors() []error { return m }

// SegmentFieldBoolValidationError is the validation error returned by
// SegmentFieldBool.Validate if the designated constraints aren't met.
type SegmentFieldBoolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldBoolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldBoolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldBoolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldBoolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldBoolValidationError) ErrorName() string { return "SegmentFieldBoolValidationError" }

// Error satisfies the builtin error interface
func (e SegmentFieldBoolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldBool.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldBoolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldBoolValidationError{}

// Validate checks the field values on SegmentFieldRepeatedBool with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedBool) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedBool with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedBoolMultiError, or nil if none found.
func (m *SegmentFieldRepeatedBool) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedBool) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedBoolMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedBoolMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRepeatedBool.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRepeatedBoolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedBoolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedBoolMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedBoolValidationError is the validation error returned by
// SegmentFieldRepeatedBool.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedBoolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedBoolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedBoolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedBoolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedBoolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedBoolValidationError) ErrorName() string {
	return "SegmentFieldRepeatedBoolValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedBoolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedBool.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedBoolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedBoolValidationError{}

// Validate checks the field values on SegmentFieldBlob with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldBlob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldBlob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldBlobMultiError, or nil if none found.
func (m *SegmentFieldBlob) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldBlob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SegmentFieldBlobMultiError(errors)
	}

	return nil
}

// SegmentFieldBlobMultiError is an error wrapping multiple validation errors
// returned by SegmentFieldBlob.ValidateAll() if the designated constraints
// aren't met.
type SegmentFieldBlobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldBlobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldBlobMultiError) AllErrors() []error { return m }

// SegmentFieldBlobValidationError is the validation error returned by
// SegmentFieldBlob.Validate if the designated constraints aren't met.
type SegmentFieldBlobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldBlobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldBlobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldBlobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldBlobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldBlobValidationError) ErrorName() string { return "SegmentFieldBlobValidationError" }

// Error satisfies the builtin error interface
func (e SegmentFieldBlobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldBlob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldBlobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldBlobValidationError{}

// Validate checks the field values on SegmentFieldRepeatedBlob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedBlob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedBlob with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedBlobMultiError, or nil if none found.
func (m *SegmentFieldRepeatedBlob) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedBlob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SegmentFieldRepeatedBlobMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedBlobMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRepeatedBlob.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRepeatedBlobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedBlobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedBlobMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedBlobValidationError is the validation error returned by
// SegmentFieldRepeatedBlob.Validate if the designated constraints aren't met.
type SegmentFieldRepeatedBlobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedBlobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedBlobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedBlobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedBlobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedBlobValidationError) ErrorName() string {
	return "SegmentFieldRepeatedBlobValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedBlobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedBlob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedBlobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedBlobValidationError{}

// Validate checks the field values on SegmentFieldRangeInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRangeInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRangeInt with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRangeIntMultiError, or nil if none found.
func (m *SegmentFieldRangeInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRangeInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return SegmentFieldRangeIntMultiError(errors)
	}

	return nil
}

// SegmentFieldRangeIntMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRangeInt.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRangeIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRangeIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRangeIntMultiError) AllErrors() []error { return m }

// SegmentFieldRangeIntValidationError is the validation error returned by
// SegmentFieldRangeInt.Validate if the designated constraints aren't met.
type SegmentFieldRangeIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRangeIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRangeIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRangeIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRangeIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRangeIntValidationError) ErrorName() string {
	return "SegmentFieldRangeIntValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRangeIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRangeInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRangeIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRangeIntValidationError{}

// Validate checks the field values on SegmentFieldRepeatedRangeInt with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedRangeInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedRangeInt with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedRangeIntMultiError, or nil if none found.
func (m *SegmentFieldRepeatedRangeInt) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedRangeInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldRepeatedRangeIntValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldRepeatedRangeIntValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldRepeatedRangeIntValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentFieldRepeatedRangeIntMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedRangeIntMultiError is an error wrapping multiple
// validation errors returned by SegmentFieldRepeatedRangeInt.ValidateAll() if
// the designated constraints aren't met.
type SegmentFieldRepeatedRangeIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedRangeIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedRangeIntMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedRangeIntValidationError is the validation error returned
// by SegmentFieldRepeatedRangeInt.Validate if the designated constraints
// aren't met.
type SegmentFieldRepeatedRangeIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedRangeIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedRangeIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedRangeIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedRangeIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedRangeIntValidationError) ErrorName() string {
	return "SegmentFieldRepeatedRangeIntValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedRangeIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedRangeInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedRangeIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedRangeIntValidationError{}

// Validate checks the field values on SegmentFieldRangeFloat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRangeFloat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRangeFloat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRangeFloatMultiError, or nil if none found.
func (m *SegmentFieldRangeFloat) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRangeFloat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return SegmentFieldRangeFloatMultiError(errors)
	}

	return nil
}

// SegmentFieldRangeFloatMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldRangeFloat.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldRangeFloatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRangeFloatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRangeFloatMultiError) AllErrors() []error { return m }

// SegmentFieldRangeFloatValidationError is the validation error returned by
// SegmentFieldRangeFloat.Validate if the designated constraints aren't met.
type SegmentFieldRangeFloatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRangeFloatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRangeFloatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRangeFloatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRangeFloatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRangeFloatValidationError) ErrorName() string {
	return "SegmentFieldRangeFloatValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRangeFloatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRangeFloat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRangeFloatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRangeFloatValidationError{}

// Validate checks the field values on SegmentFieldRepeatedRangeFloat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedRangeFloat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedRangeFloat with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedRangeFloatMultiError, or nil if none found.
func (m *SegmentFieldRepeatedRangeFloat) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedRangeFloat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldRepeatedRangeFloatValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldRepeatedRangeFloatValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldRepeatedRangeFloatValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentFieldRepeatedRangeFloatMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedRangeFloatMultiError is an error wrapping multiple
// validation errors returned by SegmentFieldRepeatedRangeFloat.ValidateAll()
// if the designated constraints aren't met.
type SegmentFieldRepeatedRangeFloatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedRangeFloatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedRangeFloatMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedRangeFloatValidationError is the validation error
// returned by SegmentFieldRepeatedRangeFloat.Validate if the designated
// constraints aren't met.
type SegmentFieldRepeatedRangeFloatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedRangeFloatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedRangeFloatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedRangeFloatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedRangeFloatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedRangeFloatValidationError) ErrorName() string {
	return "SegmentFieldRepeatedRangeFloatValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedRangeFloatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedRangeFloat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedRangeFloatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedRangeFloatValidationError{}

// Validate checks the field values on SegmentFieldGeoPoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldGeoPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldGeoPoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldGeoPointMultiError, or nil if none found.
func (m *SegmentFieldGeoPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldGeoPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	// no validation rules for Y

	if len(errors) > 0 {
		return SegmentFieldGeoPointMultiError(errors)
	}

	return nil
}

// SegmentFieldGeoPointMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldGeoPoint.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldGeoPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldGeoPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldGeoPointMultiError) AllErrors() []error { return m }

// SegmentFieldGeoPointValidationError is the validation error returned by
// SegmentFieldGeoPoint.Validate if the designated constraints aren't met.
type SegmentFieldGeoPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldGeoPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldGeoPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldGeoPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldGeoPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldGeoPointValidationError) ErrorName() string {
	return "SegmentFieldGeoPointValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldGeoPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldGeoPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldGeoPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldGeoPointValidationError{}

// Validate checks the field values on SegmentFieldRepeatedGeoPoint with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedGeoPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedGeoPoint with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedGeoPointMultiError, or nil if none found.
func (m *SegmentFieldRepeatedGeoPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedGeoPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldRepeatedGeoPointValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldRepeatedGeoPointValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldRepeatedGeoPointValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentFieldRepeatedGeoPointMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedGeoPointMultiError is an error wrapping multiple
// validation errors returned by SegmentFieldRepeatedGeoPoint.ValidateAll() if
// the designated constraints aren't met.
type SegmentFieldRepeatedGeoPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedGeoPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedGeoPointMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedGeoPointValidationError is the validation error returned
// by SegmentFieldRepeatedGeoPoint.Validate if the designated constraints
// aren't met.
type SegmentFieldRepeatedGeoPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedGeoPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedGeoPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedGeoPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedGeoPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedGeoPointValidationError) ErrorName() string {
	return "SegmentFieldRepeatedGeoPointValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedGeoPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedGeoPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedGeoPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedGeoPointValidationError{}

// Validate checks the field values on SegmentFieldGeoRect with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldGeoRect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldGeoRect with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldGeoRectMultiError, or nil if none found.
func (m *SegmentFieldGeoRect) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldGeoRect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTopLeft()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentFieldGeoRectValidationError{
					field:  "TopLeft",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentFieldGeoRectValidationError{
					field:  "TopLeft",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTopLeft()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentFieldGeoRectValidationError{
				field:  "TopLeft",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBottomRight()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentFieldGeoRectValidationError{
					field:  "BottomRight",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentFieldGeoRectValidationError{
					field:  "BottomRight",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBottomRight()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentFieldGeoRectValidationError{
				field:  "BottomRight",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SegmentFieldGeoRectMultiError(errors)
	}

	return nil
}

// SegmentFieldGeoRectMultiError is an error wrapping multiple validation
// errors returned by SegmentFieldGeoRect.ValidateAll() if the designated
// constraints aren't met.
type SegmentFieldGeoRectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldGeoRectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldGeoRectMultiError) AllErrors() []error { return m }

// SegmentFieldGeoRectValidationError is the validation error returned by
// SegmentFieldGeoRect.Validate if the designated constraints aren't met.
type SegmentFieldGeoRectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldGeoRectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldGeoRectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldGeoRectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldGeoRectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldGeoRectValidationError) ErrorName() string {
	return "SegmentFieldGeoRectValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldGeoRectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldGeoRect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldGeoRectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldGeoRectValidationError{}

// Validate checks the field values on SegmentFieldRepeatedGeoRect with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentFieldRepeatedGeoRect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentFieldRepeatedGeoRect with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentFieldRepeatedGeoRectMultiError, or nil if none found.
func (m *SegmentFieldRepeatedGeoRect) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentFieldRepeatedGeoRect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentFieldRepeatedGeoRectValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentFieldRepeatedGeoRectValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentFieldRepeatedGeoRectValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentFieldRepeatedGeoRectMultiError(errors)
	}

	return nil
}

// SegmentFieldRepeatedGeoRectMultiError is an error wrapping multiple
// validation errors returned by SegmentFieldRepeatedGeoRect.ValidateAll() if
// the designated constraints aren't met.
type SegmentFieldRepeatedGeoRectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentFieldRepeatedGeoRectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentFieldRepeatedGeoRectMultiError) AllErrors() []error { return m }

// SegmentFieldRepeatedGeoRectValidationError is the validation error returned
// by SegmentFieldRepeatedGeoRect.Validate if the designated constraints
// aren't met.
type SegmentFieldRepeatedGeoRectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentFieldRepeatedGeoRectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentFieldRepeatedGeoRectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentFieldRepeatedGeoRectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentFieldRepeatedGeoRectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentFieldRepeatedGeoRectValidationError) ErrorName() string {
	return "SegmentFieldRepeatedGeoRectValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentFieldRepeatedGeoRectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentFieldRepeatedGeoRect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentFieldRepeatedGeoRectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentFieldRepeatedGeoRectValidationError{}

// Validate checks the field values on PutSegmentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutSegmentRequestMultiError, or nil if none found.
func (m *PutSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutSegmentRequestValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutSegmentRequestValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutSegmentRequestValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutSegmentRequestMultiError(errors)
	}

	return nil
}

// PutSegmentRequestMultiError is an error wrapping multiple validation errors
// returned by PutSegmentRequest.ValidateAll() if the designated constraints
// aren't met.
type PutSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutSegmentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutSegmentRequestMultiError) AllErrors() []error { return m }

// PutSegmentRequestValidationError is the validation error returned by
// PutSegmentRequest.Validate if the designated constraints aren't met.
type PutSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutSegmentRequestValidationError) ErrorName() string {
	return "PutSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutSegmentRequestValidationError{}

// Validate checks the field values on PutSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutSegmentResponseMultiError, or nil if none found.
func (m *PutSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PutSegmentResponseMultiError(errors)
	}

	return nil
}

// PutSegmentResponseMultiError is an error wrapping multiple validation errors
// returned by PutSegmentResponse.ValidateAll() if the designated constraints
// aren't met.
type PutSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutSegmentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutSegmentResponseMultiError) AllErrors() []error { return m }

// PutSegmentResponseValidationError is the validation error returned by
// PutSegmentResponse.Validate if the designated constraints aren't met.
type PutSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutSegmentResponseValidationError) ErrorName() string {
	return "PutSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutSegmentResponseValidationError{}

// Validate checks the field values on GetSegmentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentRequestMultiError, or nil if none found.
func (m *GetSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentRequestValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSegmentRequestMultiError(errors)
	}

	return nil
}

// GetSegmentRequestMultiError is an error wrapping multiple validation errors
// returned by GetSegmentRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentRequestMultiError) AllErrors() []error { return m }

// GetSegmentRequestValidationError is the validation error returned by
// GetSegmentRequest.Validate if the designated constraints aren't met.
type GetSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentRequestValidationError) ErrorName() string {
	return "GetSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentRequestValidationError{}

// Validate checks the field values on GetSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentResponseMultiError, or nil if none found.
func (m *GetSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentResponseValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSegmentResponseMultiError(errors)
	}

	return nil
}

// GetSegmentResponseMultiError is an error wrapping multiple validation errors
// returned by GetSegmentResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentResponseMultiError) AllErrors() []error { return m }

// GetSegmentResponseValidationError is the validation error returned by
// GetSegmentResponse.Validate if the designated constraints aren't met.
type GetSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentResponseValidationError) ErrorName() string {
	return "GetSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentResponseValidationError{}

// Validate checks the field values on DeleteSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSegmentRequestMultiError, or nil if none found.
func (m *DeleteSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteSegmentRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteSegmentRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteSegmentRequestValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteSegmentRequestMultiError(errors)
	}

	return nil
}

// DeleteSegmentRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSegmentRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSegmentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSegmentRequestMultiError) AllErrors() []error { return m }

// DeleteSegmentRequestValidationError is the validation error returned by
// DeleteSegmentRequest.Validate if the designated constraints aren't met.
type DeleteSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSegmentRequestValidationError) ErrorName() string {
	return "DeleteSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSegmentRequestValidationError{}

// Validate checks the field values on DeleteSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSegmentResponseMultiError, or nil if none found.
func (m *DeleteSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSegmentResponseMultiError(errors)
	}

	return nil
}

// DeleteSegmentResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteSegmentResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSegmentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSegmentResponseMultiError) AllErrors() []error { return m }

// DeleteSegmentResponseValidationError is the validation error returned by
// DeleteSegmentResponse.Validate if the designated constraints aren't met.
type DeleteSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSegmentResponseValidationError) ErrorName() string {
	return "DeleteSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSegmentResponseValidationError{}
